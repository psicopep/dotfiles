" Set a few helpful variables
let s:vimrcdir = fnamemodify(resolve(expand('<sfile>:p')), ':h')
let s:vimfiles = s:vimrcdir . '/vimfiles'
let s:is_windows = has('win32') || has('win64')


"--------------------
" Basics
"--------------------

if &compatible
  set nocompatible          " Enable Vim enhancements
endif
set encoding=utf-8          " Enable utf-8 in Vim
set backspace=2             " Enable normal backspace behavior
set number relativenumber   " Set numbers column visible and relative
set incsearch nohlsearch    " Set incremental search, no highlight
set formatoptions+=j        " Remove comment char in joining lines
set fileformats=unix,dos    " Make Vim infer either unix or dos format from file
set wildignorecase          " Make find/edit cmd-complete ignore case
" Lower priority of some files on cmd-complete
set suffixes=.bak,~,.swp,.o,.obj,.pyc,.png,.jpg,.html,.out,.log,.jsonlog

" Avoid delays with ESC in terminal
" NOTE: ttimeoutlen is used for key codes. I don't think I use it,
"       but if something stop working, we should try another values.
set timeoutlen=600 ttimeoutlen=0

" Show partial command in command line
" (specially helpful to count chars/lines in Visual mode)
" NOTE: Help says this might slow down Vim in a terminal. Be aware.
set showcmd

" Enable binding to system clipboard
if s:is_windows
  set clipboard=unnamed
else
  set clipboard=unnamedplus
endif

" Disable menu loading completely (not even source menu.vim)
" (Although gui stuff, this must be done here, before "syntax on" or "filetype on")
set guioptions+=M
set guioptions-=m

" Disable colon indentation
set indentkeys-=:


"--------------------
" Plugin Loading
"--------------------

" Load bundles
let s:bundleman_rtp = s:vimfiles . '/BundleMan_rtp.vim'
if filereadable(s:bundleman_rtp)
  exec 'source ' . s:bundleman_rtp
endif

" Enable syntax highlighting and filetype support
filetype plugin indent on
if !exists('g:syntax_on')
  syntax enable
endif


"--------------------
" Visuals
"--------------------

" Set color scheme
if $DISPLAY ==# '' && !s:is_windows
  colorscheme torte
elseif s:is_windows && !has('gui_running')
  colorscheme default
else
  try
    colorscheme angr
    highlight Normal ctermbg=None guibg=Black
    highlight LineNr ctermbg=None guibg=Black
  catch /^Vim\%((\a\+)\)\=:E185/
    colorscheme torte
  endtry
endif

" Set nicer colors for complete menu
highlight Pmenu ctermbg=lightblue ctermfg=black guibg=lightblue guifg=black
highlight PmenuSel ctermbg=black ctermfg=red guibg=black guifg=red

" Set filename as window title
set title titlestring=%t

" Set tab as 4 spaces by default
set tabstop=4 softtabstop=4 shiftwidth=4 expandtab

" Group for visual autocmds
augroup visuals
  autocmd!
augroup END

" Keep equal sized windows split on diff if Vim is resized
autocmd visuals VimResized * if &diff | wincmd = | endif

" Set tab as 2 spaces in vim files
autocmd visuals FileType vim setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab

" Set default max line width to 80 and highlight excess
" (for programming languages)
set nowrap
set textwidth=79
autocmd visuals FileType c,cpp,python highlight Excess ctermbg=DarkRed guibg=DarkRed
autocmd visuals FileType c,cpp,python match Excess /\%80v.*/

" Set default max line width in text files to 150. Less is cumbersome
autocmd visuals FileType text setlocal textwidth=150

" Highlight trailing whitespace
autocmd visuals FileType * syntax match TrailingWhiteSpace "\s\+$" display
autocmd visuals FileType * highlight TrailingWhiteSpace ctermbg=Red guibg=Red

" Statusline Settings
set laststatus=2    " Always show statusline
set statusline=%f\ %m%r%=
set statusline+=\ %y\ %{&fileencoding}\|%{&fileformat}
set statusline+=\ %l,%v\ %p%%

" Disable preview window for autocompletion info
" (use autocmd because plugins may enable preview)
autocmd visuals FileType * setlocal completeopt-=preview


"--------------------
" Mappings
"--------------------

" Alt mapping helper
function! s:AltMapping(modes, nore, keys, expression)
  for l:mode in split(a:modes, '\zs')
    exec l:mode . a:nore . 'map ' . '<A-' . a:keys . '> ' . a:expression
    if !has('gui_running')
      exec l:mode . a:nore . 'map ' . '' . a:keys . ' ' . a:expression
    endif
  endfor
endfunction

" Disable annoying ex mode
nnoremap Q <Nop>

" Nicer Buffer Navigation
set hidden
cabbrev q <c-r>=(getcmdtype()==':' && getcmdpos()==1 && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) > 1? 'bd' : 'q')<CR>
cabbrev wq <c-r>=(getcmdtype()==':' && getcmdpos()==1 && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) > 1? 'w<bar>bd' : 'wq')<CR>
call s:AltMapping('n', 'nore', 's', ':ls<cr>:b ')

" Nicer QuickFix Navigation
nnoremap <C-k> :cp<cr>
nnoremap <C-j> :cn<cr>

" Insert mode TAB for autocompletion
function! s:insert_tab()
  return pumvisible() ? "\<c-n>" : "\<Tab>"
endfunction
function! s:insert_s_tab()
  return pumvisible() ? "\<c-p>" : "\<S-Tab>"
endfunction
inoremap <Tab> <C-r>=<SID>insert_tab()<CR>
inoremap <S-Tab> <C-r>=<SID>insert_s_tab()<CR>

" Normal mode jk as page down / page up
call s:AltMapping('nv', 'nore', 'j', '<PageDown>')
call s:AltMapping('nv', 'nore', 'k', '<PageUp>')

" Map Ã± to ; and Ã‘ to :
map Ã‘ :
map Ã± ;

" Map A-w to C-w for easier window navigation
call s:AltMapping('n', '', 'w', '<C-w>')

" Map space to :
nnoremap <Space> :

" Edit with precharged wildcards
call s:AltMapping('n', 'nore', 'e', ':e **/*')

" Disable ZZ (avoid issues with missing '>' key)
nnoremap ZZ <Nop>

" Alt mappings for search
call s:AltMapping('n', 'nore', '-', '/')
call s:AltMapping('n', 'nore', '_', '?')


"--------------------
" Plugins Config
"--------------------

" SimpleTree
call s:AltMapping('n', 'nore', 'f', ':SimpleTreeToggle<CR>')
let g:simpletree_use_arrows = 1

" Jedi
let g:jedi#auto_initialization = 1
let g:jedi#completions_enabled = 1
let g:jedi#popup_on_dot = 0
let g:jedi#popup_select_first = 1
let g:jedi#use_tabs_not_buffers = 0
let g:jedi#goto_command = 'Qd'
let g:jedi#goto_assignments_command = 'Qa'
let g:jedi#documentation_command = 'Qh'
let g:jedi#usages_command = 'Qu'
let g:jedi#force_py_version = 3

" Clang_complete
let g:clang_make_default_keymappings = 1
let g:clang_auto_select = 1
let g:clang_snippets = 1

" OmniSharp
if stridx(&rtp, 'omnisharp-vim') != -1
  " let g:Omnisharp_start_server = 0
  augroup omnisharp_autocmd
    autocmd!
    autocmd FileType cs setlocal omnifunc=OmniSharp#Complete
    autocmd FileType cs nnoremap Qd :OmniSharpGotoDefinition<cr>
    autocmd FileType cs nnoremap Qi :OmniSharpFindImplementations<cr>
    autocmd FileType cs nnoremap Qt :OmniSharpFindType<cr>
    autocmd FileType cs nnoremap Qs :OmniSharpFindSymbol<cr>
    autocmd FileType cs nnoremap Qu :OmniSharpFindUsages<cr>
    autocmd FileType cs nnoremap Qm :OmniSharpFindMembers<cr> "finds members in the current buffer
  augroup END
endif

" Java Complete
if stridx(&rtp, 'vim-javacomplete2') != -1
  augroup javacomplete_autocmd
    autocmd!
    autocmd FileType java setlocal omnifunc=javacomplete#Complete
  augroup END
endif

" Map uppercase word motion to CamelCaseMotion
map <S-W> <Plug>CamelCaseMotion_w
map <S-B> <Plug>CamelCaseMotion_b
map <S-E> <Plug>CamelCaseMotion_e

" Vim-Sneak
let g:sneak#streak = 1


"--------------------
" Enhancements
"--------------------

" AutoComplete
set completeopt=menu,menuone
let s:noinsert_fix = "\<c-p>"
let s:last_substr = ''
let s:last_accept = 0
let s:omni = 0
function! s:AutoCompleteShow()
  let l:pos = getpos('.')
  let l:substr = matchstr(strpart(getline(l:pos[1]), 0, l:pos[2]-1), "[^ \t]*$")
  let l:omni_failed = l:substr ==# s:last_substr && s:omni
  if !s:last_accept && (l:substr !=# s:last_substr || l:omni_failed)
    let s:last_substr = l:substr
    let s:omni = 0
    if !pumvisible()
      if l:omni_failed && l:substr =~# '\k\+\(\.\|->\|::\)\k\k\k*$'
        return feedkeys("\<c-g>\<c-g>\<c-n>" . s:noinsert_fix, 'i')
      elseif !l:omni_failed && strlen(&l:omnifunc) > 0 && l:substr =~# '\k\+\(\.\|->\|::\)\k*$'
        let s:omni = 1
        return feedkeys("\<c-x>\<c-o>" . s:noinsert_fix, 'i')
      elseif l:substr =~# '/\k\k\+$'
        return feedkeys("\<c-x>\<c-f>" . s:noinsert_fix, 'i')
      elseif l:substr =~# '\k\k\+$'
        return feedkeys("\<c-n>" . s:noinsert_fix, 'i')
      endif
    endif
  endif
  let s:last_accept = 0
endfunction
augroup auto_complete
  autocmd!
  autocmd TextChangedI * noautocmd call <SID>AutoCompleteShow()
augroup END
inoremap <silent> <expr> <BS> "\<c-g>\<c-g>\<BS>"

" Grep (with ripgrep if available)
if s:is_windows
  " Use ripgrep in Vim folder
  let s:rg_path = s:vimrcdir . '/ripgrep-0.8.1/'
  let &grepprg = s:rg_path . 'rg --vimgrep --no-heading'
  set grepformat=%f:%l:%c:%m,%f:%l:%m
elseif executable('rg')
  " Use global ripgrep
  let &grepprg = 'rg --vimgrep --no-heading'
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif
command! -nargs=+ Grep :silent grep! <args> | cwindow | redraw!

" Linting
let s:lint_marks = {}
let s:lint_texts = {}
sign define piet text=>> texthl=Search
function! s:SetLintMarks() " Chunks unashamedly borrowed from errormarker.vim
  if !has('signs')
    return
  endif
  for l:key in keys(s:lint_marks)
    execute ':sign unplace ' . l:key
  endfor
  let s:lint_marks = {}
  let s:lint_texts = {}
  for l:d in getqflist()
    if (l:d.bufnr == 0 || l:d.lnum == 0)
      continue
    endif
    let l:key = l:d.bufnr . l:d.lnum
    if has_key(s:lint_marks, l:key)
      continue
    endif
    let s:lint_marks[l:key] = 1
    execute ':sign place ' . l:key . ' line=' . l:d.lnum . ' name=piet'
          \ . ' buffer=' . l:d.bufnr
    let s:lint_texts[l:key] = l:d.text
  endfor
endfunction
function! s:ShowLintText() " Bits inspired by Syntastic
  let l:key = bufnr('%') . line('.')
  if has_key(s:lint_texts, l:key)
    let l:msg = s:lint_texts[l:key]
    let l:msg = substitute(l:msg, "\n", '', 'g')
    let l:chunks = split(l:msg, "\t", 1)
    let l:msg = join(l:chunks[:-2], ' ') . ' ' . l:chunks[-1]
    " Cut down msg to avoid conflict with showcmd
    let l:msg = strpart(l:msg, 0, &columns - (&showcmd ? 12 : 1))
    echo l:msg
  else
    echo ''
  endif
endfunction
command! -nargs=0 Lint :silent! make! | call <SID>SetLintMarks() | redraw!
function! s:GetPyLint()
  if filereadable('venv/bin/pylint')
    return 'venv/bin/pylint'
  elseif filereadable('venv/Scripts/pylint')
    return 'venv/Scripts/pylint'
  else
    return 'pylint'
  endif
endfunction
augroup auto_lint
  autocmd!
  " Lint on write
  autocmd BufWritePost * Lint
  if has('signs')
    autocmd CursorMoved * call <SID>ShowLintText()
  endif
  " Python
  autocmd FileType python exe ' setlocal makeprg=' . <SID>GetPyLint() . '\ --reports=n\ --msg-template=\"{path}:{line}:\ {msg}\"\ %:p'
  autocmd FileType python setlocal errorformat=%f:%l:\ %m
augroup END

" Smart marks handling (inspired by Vim-Bookmarks)
let s:all_marks = map(range(97, 122), 'nr2char(v:val)')
let s:all_marks = filter(s:all_marks, 'v:val !=# "m" && v:val !=# "j"')
function! s:InitMarks()
  if !exists('b:next_marks')
    delmarks!
    let b:next_marks = copy(s:all_marks)
  endif
endfunction
function! s:AutoMark()
  call s:InitMarks()
  let l:mark = nr2char(getchar())
  redraw
  if l:mark ==# 'j'
    try
      exe 'marks ' . join(s:all_marks, ',') . '<cr>'
      let l:mark = nr2char(getchar())
      redraw
      execute "normal! '" . l:mark
    catch /^Vim\%((\a\+)\)\=:E283/
      echo 'No automarks found'
    endtry
  else
    if l:mark ==# 'm'
      let l:mark = remove(b:next_marks, 0)
    else
      let l:mark = remove(b:next_marks, index(b:next_marks, l:mark))
    endif
    call add(b:next_marks, l:mark)
    exe 'k' . l:mark
    echo l:mark
  endif
endfunction
nnoremap <silent> m :call <SID>AutoMark()<CR>

" If swapfile exists open readonly (bypass dialog)
augroup NoSimultaneousEdits
  autocmd!
  autocmd SwapExists * let v:swapchoice = 'o'
  autocmd SwapExists * echo 'Duplicate edit session (readonly)'
  autocmd SwapExists * echohl None
  autocmd SwapExists * sleep 2
augroup END

" Shortly blink the line and column of the search match
function! s:HLNext (blinktime)
  set invcursorline invcursorcolumn
  redraw
  exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
  set invcursorline invcursorcolumn
  redraw
endfunction
nnoremap <silent> *   *:call <SID>HLNext(0.1)<cr>
nnoremap <silent> #   #:call <SID>HLNext(0.1)<cr>
nnoremap <silent> n   n:call <SID>HLNext(0.1)<cr>
nnoremap <silent> N   N:call <SID>HLNext(0.1)<cr>

" Tags
let s:ctags = s:is_windows ? s:vimrcdir . '/ctags58/ctags.exe' : 'ctags'
let s:tags = []
function! s:JumpToTag()
  let l:tag_info = split(s:tags[line('.')-1], '\t')
  wincmd q
  call cursor(0, 0)
  let l:pattern = substitute(l:tag_info[2], '^\/\(.\{-}\)\/;"$', '\1', '')
  call search('\M' . l:pattern)
  normal! _
endfunction
function! s:ShowTags(jump)
  let s:tags = split(system(s:ctags . ' -f - --format=2 --fields=fKs --python-kinds=-i ' . expand('%')), '\n')
  let l:lines = []
  for l:tag in s:tags
    call add(l:lines, substitute(l:tag, '\(.\{-}\)\t.\{-}\t.\{-}\t\(.\{-}\)', '\1\t\t\t\t\t\2', ''))
  endfor
  silent keepalt botright new
  setlocal winfixwidth nobuflisted buftype=nofile noswapfile bufhidden=wipe
  call setline(1, l:lines)
  setlocal nomodifiable
  nnoremap <buffer> <silent> <CR> :call <SID>JumpToTag()<CR>
  nnoremap <buffer> <silent> <ESC> :wincmd q<CR>
  nnoremap <buffer> / /\c^
  if a:jump
    call feedkeys('/')
  endif
endfunction
call s:AltMapping('n', 'nore', 't', ':call <SID>ShowTags(0)<CR>')
call s:AltMapping('n', 'nore', 'g', ':call <SID>ShowTags(1)<CR>')


"--------------------
" Project Support
"--------------------

" VirtualEnv Support
function! s:GetVenvDirsAndVer(virtualenv)
  if isdirectory(a:virtualenv . '/bin')
    let l:bin = a:virtualenv . '/bin'
    let l:lib = glob(a:virtualenv . '/lib/*/site-packages')
    let l:python3 = filereadable(l:bin . '/python3')
  elseif isdirectory(a:virtualenv . '/Scripts')
    let l:bin = a:virtualenv . '/Scripts'
    let l:lib = glob(a:virtualenv . '/Lib/site-packages')
    let l:python3 = filereadable(l:bin . '/python3.dll')
  else
    return
  endif
  return [l:bin, l:lib, l:python3]
endfunction
function! s:SetupVirtualEnv(virtualenv) abort
  let [l:bin, l:lib, l:python3] = s:GetVenvDirsAndVer(a:virtualenv)
  if l:python3 && has('python3')
    python3 import sys, os, vim
    python3 sys.path.insert(0, vim.eval('l:lib'))
    python3 os.environ['PATH'] = vim.eval('l:bin') + os.pathsep + os.environ['PATH']
    " NOTE: We need to force Jedi's Python version because it may have been
    "       auto setup to a wrong version.
    let g:jedi#force_py_version = 3
  elseif !l:python3 && has('python')
    python import sys, os, vim
    python sys.path.insert(0, vim.eval('l:lib'))
    python os.environ['PATH'] = vim.eval('l:bin') + os.pathsep + os.environ['PATH']
    " NOTE: We need to force Jedi's Python version because it may have been
    "       auto setup to a wrong version.
    let g:jedi#force_py_version = 2
  endif
endfunction
function! s:TearDownVirtualEnv(virtualenv) abort
  let [l:bin, l:lib, l:python3] = s:GetVenvDirsAndVer(a:virtualenv)
  if l:python3 && has('python3')
    python3 import vim, sys, os
    python3 sys.path.remove(vim.eval('l:lib'))
    python3 os.environ['PATH'] = os.environ['PATH'].replace(vim.eval('l:bin') + os.pathsep, '')
  elseif !l:python3 && has('python')
    python import vim, sys, os
    python sys.path.remove(vim.eval('l:lib'))
    python os.environ['PATH'] = os.environ['PATH'].replace(vim.eval('l:bin') + os.pathsep, '')
  endif
  " TODO: See if there is a way to restore Jedi's Python version to before forcing it
endfunction

" Automatic Project Setup
function! s:GoToProjectRoot()
  if !exists('b:project_root')
    let l:bufdir = fnamemodify(resolve(expand('%:p')), ':h')
    for l:hintdir in ['.git', '.hg', 'venv']
      let b:project_root = finddir(l:hintdir, l:bufdir . ';')
      if b:project_root !=# ''
        let b:project_root = fnamemodify(b:project_root, ':h')
        break
      endif
    endfor
  endif
  if b:project_root !=# ''
    exe 'cd ' . b:project_root
  endif
endfunction
let s:project_venv = ''
function! s:SetupProject()
  call s:GoToProjectRoot()
  let l:filetype = &filetype
  if l:filetype ==# 'python'
    if s:project_venv !=# ''
      call s:TearDownVirtualEnv(s:project_venv)
      let s:project_venv = ''
    endif
    let l:venv = getcwd() . '/venv'
    if isdirectory(l:venv)
      call s:SetupVirtualEnv(l:venv)
      let s:project_venv = l:venv
      " Set max line width to 120 and highlight excess
      match Excess /\%120v.*/
      setlocal nowrap textwidth=119
      " Ignore venv in file completion
      set wildignore+=venv*/*
    endif
  endif
endfunction
augroup AutoProjectSetup
  autocmd!
  autocmd BufWinEnter * call <SID>SetupProject()
augroup END


"--------------------
" Miscelaneous
"--------------------

" GUID Generator (this places a random guid in unnamedplus register)
function! s:GenerateUUID()
  if has('python3')
    python3 import uuid; vim.command('let @+ = "%s"' % str(uuid.uuid4()))
  elseif has('python')
    python import uuid; vim.command('let @+ = "%s"' % str(uuid.uuid4()))
  endif
endfunction
nnoremap Zg :call <SID>GenerateUUID()<CR>


"--------------------
" GVIMRC
"--------------------

if has('gui_running')

" Set Font
if s:is_windows
  set guifont=DejaVu_Sans_Mono:h11:cANSI:qDRAFT
else
  set guifont=Monospace\ Bold\ 14
endif

" Remove toolbar and scroll bar
set guioptions-=T  "remove toolbar
set guioptions-=r  "remove right-hand scroll bar
set guioptions-=R  "remove right-hand scroll bar on vertical split
set guioptions-=l  "remove left-hand scroll bar
set guioptions-=L  "remove left-hand scroll bar on vertical split

" Set nicer colors for folding
highlight Folded guibg=chocolate4 guifg=black

endif
